import sys, os
from modeller import *
from modeller.scripts import complete_pdb

# Usage Info

if len(sys.argv) > 0:
	if (sys.argv[1]) == "--help":
		print "---------------------------------------------------------"
		print "DOPE CALC. - by THIAGO LIPINSKI-PAES"
		print "---------------------------------------------------------"
		print "COMMAND: python dopecalc.py trajectory.pdb model output.dat"
		print "---------------------------------------------------------"		
		print "where: \n"
		print "trajectory.pdb: a multi-model trajectory,"
	  	print "model: the model to compute,"
		print "---------------------------------------------------------"	
		quit()

# Setup Log

log.level(output=0, notes=0, warnings=0, errors=1, memory=0)
#log.none()
#log.minimal()

env = environ()
env.libs.topology.read(file='$(LIB)/top_heav.lib')
env.libs.parameters.read(file='$(LIB)/par.lib')

#sys.argv[1] eh trajectory
#sys.argv[2] eh model

# Check Results Directory
directory = "../Results/DOPE/"

if (not os.path.exists(directory)):
	os.makedirs(directory)

# Setup Outputs
dopeText = []
dopeNtext = []

input_name = os.path.splitext(sys.argv[1])[0]
outputfile1 = directory + input_name[6:] + "_M" + sys.argv[2] + "_DOPE_0.dat"
outputfile2 = directory + input_name[6:] + "_M" + sys.argv[2] + "_DOPE_1.dat"

if(os.path.isfile(outputfile1)):
	os.system("rm " + outputfile1)

if(os.path.isfile(outputfile2)):
	os.system("rm " + outputfile2)

output1 = open(outputfile1, "ab")
output2 = open(outputfile2, "ab")

# Write Header

#dopeNtext = str(i) + "\t" + str(zscore)  + "\n"
dopeText = "@    title \"DOPE Score\"\n"
output1.write(dopeText) 
dopeText = "@    title \"Normalized DOPE Score\"\n"
output2.write(dopeText)
dopeText = "@    xaxis  label \"Time (ps)\n"
output1.write(dopeText) 
output2.write(dopeText)
dopeText = "@    yaxis  label \"DOPE\n"
output1.write(dopeText) 
output2.write(dopeText)
dopeText = "@TYPE xy\n"
output1.write(dopeText) 
output2.write(dopeText)
#dopeText = "@ view 0.15, 0.15, 0.75, 0.85\n"
#output1.write(dopeText) 
#output2.write(dopeText)
dopeText = "@ legend on\n"
output1.write(dopeText) 
output2.write(dopeText)
dopeText = "@ legend box on\n"
output1.write(dopeText) 
output2.write(dopeText)
dopeText = "@ legend loctype view\n"
output1.write(dopeText) 
output2.write(dopeText)
#dopeText = "@ legend 0.78, 0.8\n"
#output1.write(dopeText) 
#output2.write(dopeText)
dopeText = "@ legend length 2\n"
output1.write(dopeText) 
output2.write(dopeText)
dopeText = "@ s1 legend \"012K\"\n"
output1.write(dopeText) 
output2.write(dopeText)

# Read a model previously generated by Modeller's automodel class
input = input_name[3:] + "_M" + sys.argv[2] + ".dat"
mdl = complete_pdb(env, input)

# Select all atoms in the first chain
atmsel = selection(mdl.chains[0])

score = atmsel.assess_dope()
zscore = mdl.assess_normalized_dope()

dopeText = sys.argv[2] + "\t" + str(score) + "\n"
dopeNtext = sys.argv[2] + "\t" + str(zscore)  + "\n"

# Write Results
output1.write(dopeText)
output2.write(dopeNtext)

# Finally...
output1.close	
output2.close	

#print score
#print zscore

#The DOPE model score is designed for selecting the best structure from a collection of models built by MODELLER.
# (For example, you could build multiple automodel models by setting automodel.ending_model,
#  and select the model that returns the lowest DOPE score.) The score is unnormalized with respect to the protein size 
#  and has an arbitrary scale, therefore scores from different proteins cannot be compared directly. If you wish to do this, 
#  use model.assess_normalized_dope() instead, which returns a Z-score.
